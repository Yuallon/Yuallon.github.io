
### Git是什么？

Git与其他版本控制系统的主要差别在于Git对待数据的方法。CVS，Subversion，Perforce，Bazaar等系统是以**文件变更列表的方式存储信息，将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异--基于差异(delta-based)的版本控制系统**。

![](/otherVCS.png)

Figure1: 存储每个文件与初始版本的差异

也就是说，基于差异的版本控制系统，只关注不同版本间的差别，只对有差别的文件做记录。

然而，Git对待数据方式与之不同。**Git把数据看成一些列的快照，每次提交or保存项目状态时，Git都会对所有文件(modified or unmodified)创建一个快照，并保存这个快照索引。**为了效率，如果文件没有修改，Git不再重新存储该文件，而是在快照的索引中保留一个链接指向先前存储的文件。所以，Git对待数据更像是一个**快照流**。

![](/gitVCS)

Figure2: Git存储项目随时间改变的快照

正是，Git这样对待数据的方式(快照)，每次操作都完整保存了上次项目，这更像是一个小型文件系统，而不是简单的VCS。这种方式带来的好处会在**Git分支**详细讨论。

### Git对项目的操作

#### 几乎所有的操作都是本地执行

当你从服务器克隆(clone)一个项目时，Git会在本地新建一个完全一样的仓库。这样Git中的绝大多数操作都只需要访问本地文件和资源。大大提高了Git访问文件的速度。唯一需要网络的时候，是将本地仓库关联到远程仓库的时候。

所以，即使在断网的情况下，我们也能对项目进行任何操作。只需等待有网络连接的时候再上传更新文件到服务器。

#### Git保证完整性

**Git所有的数据在存储前都计算校验和，然后以校验和来引用。**这意味着，不能看在Git不知情的情况下更改任何文件内容or目录内容。

Git用以计算校验和的机制叫做**SHA-1散列(hash, 哈希)**，是由40个十六进制字符(0-9, a-f)组成的字符串，这是基于Git文件的内容或目录结构计算出来的。看起来这样

```
24b9da6552252987aa493b52f8696cd6d3b00373
```

**Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。**

#### Git一般只添加数据

在执行Git操作时，几乎只往Git数据库中添加数据。对于未提交的文件有可能丢失or弄乱修改的内容，但是一旦Git快照，就难以再丢失数据，因为你很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。

### 三种状态

Git有三种状态，不同的状态代表你对文件不同的操作。

1. **已修改(modified)**：表示更新了仓库中的文件(修改上一个快照中的文件or添加新文件)，没有做当前版本标记，也没有保存到数据库中。
2. **已暂存(staged)**：表示对一个已修改文件or一个新添的文件的当前版本做了标记，使之包含在下次提交的快照中。
3. **已提交(committed)**：表示数据已经安全保存在本地数据库中，如果有网络连接可以直接关联到服务器上。

这样意味着Git项目有三个阶段：工作区、暂存区和仓库(Git目录)

![](/gitRepository.png)

Figure3: 工作区、暂存区 and Git仓库

- 工作区：是对项目的某个版本独立提取出来的内容，放在磁盘上供你使用或修改
- 暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录里。术语叫索引。
- Git仓库：用来保存项目的元数据和对象数据库的地方。是Git最重要的部分，从其他计算机克隆仓库时，复制的就是这里的数据。

**工作流程**：

1. 在工作区修改文件。*git init* 如果是第一次新建的文件夹，用这个命令将该目录转换成Git仓库。如果是clone的Git仓库或已存在的Git仓库，则不用执行这个命令。
2. 将你想要下次提交的更改选择性暂存，这样只有只会将更改的部分添加到暂存区。*git add xx.py*
3. 提交更新，找到暂存区的文件，将快照永久性存储到Git目录。*git commit -m "XXX"*

如果 Git 目录中保存着特定版本的文件，就属于 **已提交** 状态。 如果文件已修改并放入暂存区，就属于 **已暂存** 状 态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 **已修改** 状态。



