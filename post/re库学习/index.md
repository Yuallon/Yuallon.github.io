
### 前言

正则表达式（regular expression：RE）就是为了，在诸多string、数字等组合的数据中，给出某一类数据的通用代码表达式。方便我们对信息的提取。

![正则表达式示例](/正则表达式示例.jpg)

Figure1: 正则表达式示例，一行胜千言！

**用途：**

- 表达文本类型的特征（病毒、入侵等）
- 同时查找或替换一组字符串
- 匹配字符串的全部或部分
- 。。。

### 正则表达式的常用操作符

| 操作符 |               说明               |                   实例                    |
| :----: | :------------------------------: | :---------------------------------------: |
|   .    |         表示任何单个字符         |                                           |
|   []   |  字符集，对单个字符给出取值范围  | [a,b,c]表示a、b、c，[a-z]表示a到z单个字符 |
|  [^ ]  | 非字符集，对单个字符给出排除范围 |       [^abc]表示非a非b非c的单个字符       |
|   *    |   前一个字符0次或无穷多次扩展    |       abc*表示：ab, abc, abcc, ...        |
|   +    |  表示前一个字符1次或无穷次扩展   |         abc+表示：abc, abcc, ...          |
|   ?    |      前一个字符0次或1次扩展      |             abc?表示：ab, abc             |
|   \|   |    或运算，左右表达式任意一个    |         abc\|def表示：abc 或 def          |
|  {m}   |        扩展前一个字符m次         |             ab{2}c表示：abbc              |
| {m,n}  |  扩展前一个字符m至n次（含n次）   |          ab{1,2}c表示：abc, abbc          |
|   ^    |          匹配字符串开头          |      abc^表示abc且在一个字符串的开头      |
|   $    |          匹配字符串结尾          |      abc$表示abc且在一个字符串的结尾      |
|   ()   |   分组标记，内部只能用\|操作符   |   (abc)表示abc，(abc\|def)表示abc、def    |
|   \d   |     十进制数字，等价于[0-9]      |                                           |
|   \w   |   单词字符，等价于[a-zA-Z0-9_]   |                                           |

**语法示例：**

- P(Y|YT|YTH|YTHO)?N: PN, PYN, PYTN, PYTHN, PYTHON
- PYTHON+: PYTHON, PYTHONN, ...
- PY[TH]ON: PYTON, PYHON
- PY\[^TH] ?ON: PYON, PYaON, PYbON, ...
- PY{:3}N: PN, PYN, PYYN, PYYYN

**经典组合：**

- ^[A-Za-z]+$：由26个字母组成的字符串
- ^[A-Za-z0-9]+$：由26个字母和数字组成的字符串
- ^-?\d+$：整数形式的字符串
- ^[0-9]\*[1-9]\[0-9]\*$：整数形式的字符串
- [1-9]\d{5}：中国境内邮政编码，6位
- [\u4e00-\u9fa5]：匹配中文字符
- \d{3}-\d{8}|\d{4}-\d{7}：国内电话号码，010-68913536
- \d+.\d+.\d+.\d+ 或 \d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}：IP地址字符串形式
  精确写法：
  1. 0-99: [0-9]?\d
  2. 100-199: 1\d{2}
  3. 200-249: 2[0-4]\d
  4. 250-255: 25[0-5]

### Re库介绍

Re库是python的标准库，主要用于字符串匹配

**调用方式：import re**

最好采用raw string类型（原生字符串类型）：r'text'。不包含对转义符再次转义的字符串。

###Re库重要功能函数

|     函数      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|  re.search()  | 在一个字符串中搜索匹配正则表达式的第一个位置，返回mathc对象  |
|  re.match()   |    从一个字符串的开始位置起匹配正则表达式，返回match对象     |
| re.findall()  |          搜索字符串，以列表类型返回全部能匹配的字串          |
|  re.split()   |   将一个字符串按照正则表达式匹配结果进行分割，返回列表类型   |
| re.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
|   re.sub()    | 在一个字符串中替换所有匹配正则表达式的字串，返回替换后的字符串 |

在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象

```
re.search(pattern, string, flags=0)
```

- pattern：正则表达式字符串
- string：待匹配字符串
- flags：正则表达式使用时的控制标记
  - re.I或re.IGNORECASE：忽略正则表达式的大小写，[A-Z]能够匹配小写字符
  - re.M或re.MULTTLINE：正则表达式中的^操作符能够将给定字符串的每行当作匹配开始
  - re.S或re.DOTALL：正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符

 ```
re.findall(pattern, string, flags=0)
re.split(pattern, string, maxsplit=0,flags=0)
#maxsplit:最大分割数，剩余部分作为最后一个元素输出
re.finditer(pattern, string, flags=0)
re.sub(pattern, repl, string, count=0, flags)
#repl：替换匹配字符串的字符串；count：匹配的最大替换次数
 ```

### Re库的另一种等价用法

![正则表达式编译](/正则表达式编译.jpg)
Figure2: 将正则表达式的字符串形式编译成正则表达式对象

```python
regex = re.compile(pattern, flags=0)
```

|       函数       |                             说明                             |
| :--------------: | :----------------------------------------------------------: |
|  regex.search()  | 在一个字符串中搜索匹配正则表达式的第一个位置，返回mathc对象  |
|  regex.match()   |    从一个字符串的开始位置起匹配正则表达式，返回match对象     |
| regex.findall()  |          搜索字符串，以列表类型返回全部能匹配的字串          |
|  regex.split()   |   将一个字符串按照正则表达式匹配结果进行分割，返回列表类型   |
| regex.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 |
|   regex.sub()    | 在一个字符串中替换所有匹配正则表达式的字串，返回替换后的字符串 |

### Match对象介绍

在上面的函数操作中，返回的对象是match对象。下面介绍一些该对象的特征。

Match对象是一次匹配结果，包含匹配的很多信息。

**属性：**

|  属性   |                 说明                 |
| :-----: | :----------------------------------: |
| .string |             待匹配的文本             |
|   .re   | 匹配时使用的patter对象（正则表达式） |
|  .pos   |     正则表达式搜索文本的开始位置     |
| .endpos |     正则表达式搜索文本的结束位置     |

**方法：**

|   方法    |               说明               |
| :-------: | :------------------------------: |
| .group(0) |        获取匹配后的字符串        |
| .start()  | 匹配字符串在原始字符串的开始位置 |
|  .end()   | 匹配字符串在原始字符串的结束位置 |
|  .span()  |      返回(.start(), .end())      |

### 贪婪匹配和最小匹配

```
match = re.search(r'PY.*N', 'PYANBNCNDN')
match.group(0)
'PYANBNCNDN'
```

Re库默认输出匹配最长的子串，即，贪婪匹配。

```
match = re.search(r'PY.*?N', 'PYANBNCNDN')
match.group(0)
'PYAN'
```

只要输出的长度可能不同，都可以通过在操作符后增加 **?** 变成最小匹配。

- *?
- +?
- ??
- {m,n}?

###实例：京东商品定向比价

**目标：获取京东搜索页面的信息，提取商品的名称和价格**

**问题：**

- 如何定义京东搜索接口
- 翻页处理

**技术实现：requests库+re库**

#### 步骤解析

打开京东网页输入书包，查看网址构成

```
#首页网址信息
https://search.jd.com/Search?keyword=书包&qrst=1&wq=书包&stock=1&page=1&s=1&click=0
#第二页网址信息
https://search.jd.com/Search?keyword=书包&qrst=1&wq=书包&stock=1&page=3&s=54&click=0
#第三页网址信息
https://search.jd.com/Search?keyword=书包&qrst=1&wq=书包&stock=1&page=5&s=100&click=0
```

在嵩老师的教学视频里是采用的淘宝网页，可是淘宝网页需要登陆信息才可以爬取。所以我选择使用京东网页，来完成。

1. 从网址信息可以推断京东的网址的接口为：https://search.jd.com/Search?keyword=书包。由page信息可以推断，翻页操作是由 **2*第几页-1=page值** 。

2. 如果使用requests库设定的"user-agent"默认信息是不能正常访问京东页面，所以使用 **headers={'user-agent': 'Chome/10'}** 来设置用Chome浏览器访问。这样就可以正常爬取京东页面商品信息。

   