
### 前言

最近一致在学习爬虫，当提取网页信息进行处理时，可能会出现意想不到的报错，导致程序代码卡住，从而影响爬虫程序的执行。

比如：我在爬取某个图片网上的数据时，我要存储照片的相关信息，这个时候就不能保证每一个照片的信息都是完整的，对于那些信息不完整的照片，如果按照完整的信息方式去提取，就会抛出 **IndexError** 之类的报错（索引值超出范围）。

一般情况下数据不完整的信息是占少数的，当程序执行中抛出异常时，我们是希望程序可以继续执行而不被卡住。这便是这篇笔记写作的目的。

### 什么是异常？

当我们编写程序时，难免会遇到错误，有的是疏忽造成的语法错误，有的是程序内部的逻辑错误，或者是程序运行时与系统的规则冲突造成的错误。

总的来讲，错误类型可以分为：**语法错误** 和 **执行错误**。

无论是那种错误类型，当Python无法正常执行程序时，就会触发异常，如果我们对异常不做任何处理，程序就会终止运行。

### 异常处理

我们知道，如果对程序出现的异常不做任何处理，则程序就会终止运行，为了避免程序的中断，我们就要捕获出现的异常并处理它。

在Python中，使用 **try/except** 语句块捕获并处理异常。基本语法结构如下：

```
try:
    可能产生异常的代码块
except [ (Error1, Error2, ... ) [as e] ]:
    处理异常的代码块1
except [ (Error3, Error4, ... ) [as e] ]:
    处理异常的代码块2
except  [Exception]:
    处理其它异常
else:
    <语句> #如果没有发生异常，else可有可无
```

该格式中，[] 括起来的部分可以使用，也可以省略。其中各部分的含义如下：

- (Error1, Error2,...) 、(Error3, Error4,...)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型。显然，一个 except 块可以同时处理多种异常。
- [as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型（后续会用到）。
- [Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。

从`try except`的基本语法格式可以看出，try 块有且仅有一个，但 except 代码块可以有多个，且每个 except 块都可以同时处理多种异常。

注：当程序发生不同的意外情况时，会对应特定的异常类型，Python 解释器会根据该异常类型选择对应的 except 块来处理该异常。

**try/except执行流程:**

1. 开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。
2. 如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为 **捕获异常**。
3. 当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为 **处理异常**。
4. 如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。
5. 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。

**例子1：**

```
try:
    a = int(input("输入被除数："))
    b = int(input("输入除数："))
    c = a / b
    print("您输入的两个数相除的结果是：", c )
except (ValueError, ArithmeticError):
    print("程序发生了数字格式异常、算术异常之一")
except :
    print("未知异常")
print("程序继续运行")

###输出结果
输入被除数：a
程序发生了数字格式异常、算术异常之一
程序继续运行
```

上面程序中，第 6 行代码使用了（ValueError, ArithmeticError）来指定所捕获的异常类型，这就表明该 except 块可以同时捕获这 2 种类型的异常；第 8 行代码只有 except 关键字，并未指定具体要捕获的异常类型，这种省略异常类的 except 语句也是合法的，它表示可捕获所有类型的异常，一般会作为异常捕获的最后一个 except 块。

### 获取特定异常的有关信息

除此之外，由于 try 块中引发了异常，并被 except 块成功捕获，因此程序才可以继续执行，才有了“程序继续运行”的输出结果。

我们已经可以捕获程序中可能发生的异常，并对其进行处理。但是，由于一个 except 可以同时处理多个异常，那么我们如何知道当前处理的到底是哪种异常呢？

其实，每种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：

- args：返回异常的错误编号和描述字符串；
- str(e)：返回异常信息，但不包括异常信息的类型；
- repr(e)：返回较全的异常信息，包括异常信息的类型。

**例子2:**

```
try:
    1/0
except Exception as e:
    # 访问异常的错误编号和详细信息
    print(e.args)
    print(str(e))
    print(repr(e)) #repr() 函数将对象转化为供解释器读取的形式。
    
###输出结果
('division by zero',)
division by zero
ZeroDivisionError('division by zero',)
```

从程序中可以看到，由于 except 可能接收多种异常，因此为了操作方便，可以直接给每一个进入到此 except 块的异常，起一个统一的别名 e。

### 参考

- [Python try except异常处理详解（入门必读）](http://c.biancheng.net/view/4599.html)
- [Python 异常处理](https://www.w3cschool.cn/python/python-exceptions.html)
- [什么是异常处理，Python常见异常类型（入门必读）](http://c.biancheng.net/view/4593.html)

